stages:
  - test
  - build
  - docker
  - deploy

############################
# Variables globales
############################
variables:
  MAVEN_CLI_OPTS: "-B -Dmaven.repo.local=.m2/repository"
  DOCKER_BUILDKIT: "1"

############################
# Configuration par défaut
# (Maven sur runner Kubernetes)
############################
default:
  image: maven:3.9-eclipse-temurin-21
  tags:
    - kubernetes
  cache:
    key: "m2-${CI_PROJECT_ID}-${CI_COMMIT_REF_SLUG}"
    paths:
      - .m2/repository
    policy: pull-push

############################
# Tests unitaires
############################
verify:
  stage: test
  script:
    - chmod +x ./mvnw
    - ./mvnw $MAVEN_CLI_OPTS -DskipTests=false -DskipITs=true verify
  artifacts:
    when: always
    expire_in: 1 week
    paths:
      - target/surefire-reports/**
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

############################
# Tests d’intégration
############################
integration-tests:
  stage: test
  services:
    - name: postgres:16-alpine
      alias: pg
  variables:
    POSTGRES_DB: service_article
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    QUARKUS_DATASOURCE_JDBC_URL: jdbc:postgresql://pg:5432/service_article
    QUARKUS_DATASOURCE_USERNAME: postgres
    QUARKUS_DATASOURCE_PASSWORD: postgres
  script:
    - chmod +x ./mvnw
    - ./mvnw $MAVEN_CLI_OPTS -DskipTests=true -DskipITs=false verify
  artifacts:
    when: always
    expire_in: 1 week
    paths:
      - target/failsafe-reports/**
  needs: ["verify"]
  rules:
    - if: $CI_COMMIT_BRANCH

############################
# Build applicatif
############################
package:
  stage: build
  needs: ["verify"]
  script:
    - chmod +x ./mvnw
    - ./mvnw $MAVEN_CLI_OPTS -DskipTests package
  artifacts:
    expire_in: 1 week
    paths:
      - target/quarkus-app/**
      - target/*-runner.jar
  rules:
    - if: $CI_COMMIT_BRANCH

build_image:
  stage: docker
  image: docker:24-cli
  services:
    - name: docker:24-dind
      command: ["dockerd", "--host=tcp://0.0.0.0:2375", "--tls=false"]
  tags:
    - kubernetes
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: "1"
    BUILD_DATE: $(date -u +'%Y-%m-%dT%H:%M:%SZ')
  before_script:
    - echo "Waiting for Docker daemon..."
    - for i in {1..30}; do docker info > /dev/null 2>&1 && break; sleep 2; done
    - docker info
    - docker version
    - echo "Authenticating to registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - echo "Building Docker image..."
    - docker build --build-arg BUILD_DATE="$BUILD_DATE" --build-arg VCS_REF="$CI_COMMIT_SHORT_SHA" --build-arg VERSION="$CI_COMMIT_SHORT_SHA" --tag "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" --tag "$CI_REGISTRY_IMAGE:latest" .
    - echo "Pushing image to registry..."
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    - docker push "$CI_REGISTRY_IMAGE:latest"
    - echo "Build completed successfully!"
  needs: ["package"]
  rules:
    - if: $CI_COMMIT_BRANCH
      when: on_success



############################
# Déploiement production
############################
deploy:production:
  stage: deploy
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]
  tags:
    - kubernetes
  needs:
    - job: build_image
      artifacts: false
  variables:
    NAMESPACE: production
    KUBE_CONTEXT: "b-s-m/article-service:infra-home-agent"  # ← Ajout important
  before_script:
    - kubectl config get-contexts
    - kubectl config use-context "$KUBE_CONTEXT"
  script:
    # Pas besoin d'attendre le namespace, il existe déjà
    - echo "Deploying to namespace $NAMESPACE..."

    # Créer le secret registry
    - |
      kubectl create secret docker-registry registry-credentials \
        --docker-server=$CI_REGISTRY \
        --docker-username=$CI_REGISTRY_USER \
        --docker-password=$CI_REGISTRY_PASSWORD \
        --namespace=$NAMESPACE \
        --dry-run=client -o yaml | kubectl apply -f -

    # Créer les secrets de base de données
    - |
      kubectl create secret generic article-service-secrets \
        --from-literal=db.username=$QUARKUS_DATASOURCE_USERNAME \
        --from-literal=db.password=$QUARKUS_DATASOURCE_PASSWORD \
        --namespace=$NAMESPACE \
        --dry-run=client -o yaml | kubectl apply -f -

    # Créer le configmap
    - |
      kubectl create configmap article-service-config \
        --from-literal=datasource.jdbc.url=$QUARKUS_DATASOURCE_JDBC_URL \
        --namespace=$NAMESPACE \
        --dry-run=client -o yaml | kubectl apply -f -

    # Substituer les variables dans deployment.yaml
    - |
      export CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
      export CI_COMMIT_SHORT_SHA=$CI_COMMIT_SHORT_SHA
      envsubst < k8s/deployment.yaml | kubectl apply -f - -n $NAMESPACE

    # Appliquer service et ingress
    - kubectl apply -f k8s/service.yaml -f k8s/ingress.yaml -n $NAMESPACE

    # Attendre le rollout
    - kubectl rollout status deployment/article-service -n $NAMESPACE --timeout=5m
  environment:
    name: production
    kubernetes:
      namespace: production
    url: https://satisfactorysquad.freeboxos.fr/article-service
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual

deploy:branch:
  stage: deploy
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]
  tags:
    - kubernetes
  needs:
    - job: build_image
      artifacts: false
  variables:
    KUBE_CONTEXT: "b-s-m/article-service:infra-home-agent"
  before_script:
    - export NAMESPACE=$CI_COMMIT_REF_SLUG
    - kubectl config use-context "$KUBE_CONTEXT"

    # Créer le namespace s'il n'existe pas
    - kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

    # Créer les RBAC pour ce namespace
    - sed "s/NAMESPACE_PLACEHOLDER/$NAMESPACE/g" k8s/rbac-branch-template.yaml | kubectl apply -f -
  script:
    - echo "Deploying to namespace $NAMESPACE..."

    # Reste identique au deploy:production
    - |
      kubectl create secret docker-registry registry-credentials \
        --docker-server=$CI_REGISTRY \
        --docker-username=$CI_REGISTRY_USER \
        --docker-password=$CI_REGISTRY_PASSWORD \
        --namespace=$NAMESPACE \
        --dry-run=client -o yaml | kubectl apply -f -

    - |
      kubectl create secret generic article-service-secrets \
        --from-literal=db.username=$QUARKUS_DATASOURCE_USERNAME \
        --from-literal=db.password=$QUARKUS_DATASOURCE_PASSWORD \
        --namespace=$NAMESPACE \
        --dry-run=client -o yaml | kubectl apply -f -

    - |
      kubectl create configmap article-service-config \
        --from-literal=datasource.jdbc.url=$QUARKUS_DATASOURCE_JDBC_URL \
        --namespace=$NAMESPACE \
        --dry-run=client -o yaml | kubectl apply -f -

    - |
      export CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
      export CI_COMMIT_SHORT_SHA=$CI_COMMIT_SHORT_SHA
      envsubst < k8s/deployment.yaml | kubectl apply -f - -n $NAMESPACE

    - kubectl apply -f k8s/service.yaml -f k8s/ingress.yaml -n $NAMESPACE
    - kubectl rollout status deployment/article-service -n $NAMESPACE --timeout=5m
  environment:
    name: "$CI_COMMIT_REF_SLUG"
    kubernetes:
      namespace: "$CI_COMMIT_REF_SLUG"
    url: https://satisfactorysquad.freeboxos.fr/$CI_COMMIT_REF_SLUG/article-service
  rules:
    - if: $CI_COMMIT_BRANCH != "main"
